# Application Configuration
quarkus.application.name=flowcatalyst-message-router
quarkus.banner.enabled=false

# Proxy Configuration (for HTTPS behind load balancer)
# Enables proper redirect URLs when behind AWS ALB/ELB or similar proxy
quarkus.http.proxy.proxy-address-forwarding=true
quarkus.http.proxy.allow-x-forwarded=true
quarkus.http.proxy.enable-forwarded-host=true
quarkus.http.proxy.enable-forwarded-prefix=true

# Container Image Configuration
# Using standalone Gradle Jib plugin configured in build.gradle.kts
# (See: build.gradle.kts jib { ... } block)
# quarkus.container-image settings are not needed when using standalone Jib

# Uncomment to push to a registry:
# quarkus.container-image.registry=docker.io
# quarkus.container-image.push=true

# Native build configuration (for native container builds)
%native.quarkus.package.jar.enabled=false

# Logging Configuration - Dev: readable logs (not JSON)
%dev.quarkus.log.console.json.enabled=false
%dev.quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n
%dev.quarkus.log.level=INFO
%dev.quarkus.log.category."tech.flowcatalyst".level=DEBUG

# Logging Configuration - Prod: JSON structured logs
%prod.quarkus.log.console.json.enabled=true
%prod.quarkus.log.console.json.pretty-print=false
%prod.quarkus.log.level=INFO
%prod.quarkus.log.console.json.additional-field."service.name".value=flowcatalyst-message-router
%prod.quarkus.log.console.json.additional-field."service.version".value=${quarkus.application.version:1.0.0-SNAPSHOT}
%prod.quarkus.log.console.json.additional-field."environment".value=${ENVIRONMENT:production}
%prod.quarkus.log.category."tech.flowcatalyst.messagerouter.standby".level=DEBUG
%prod.quarkus.log.category."tech.flowcatalyst.messagerouter.mediator".level=INFO
%prod.quarkus.log.category."io.quarkus.redis".level=DEBUG
%prod.quarkus.log.category."io.quarkus.oidc".level=INFO
%prod.quarkus.log.category."io.quarkus.http.auth".level=INFO

# Message Router Configuration
message-router.enabled=true
message-router.queue-type=SQS
message-router.sync-interval=5m
message-router.max-pools=2000
message-router.pool-warning-threshold=1000

# Dev profile - Use embedded queue for local development
%dev.message-router.queue-type=EMBEDDED

# Embedded Queue Configuration (SQLite-based for developer builds)
message-router.embedded.visibility-timeout-seconds=30
message-router.embedded.receive-timeout-ms=1000

# Message Router Consumer Configuration
# SQS uses SYNC mode - blocking polls with virtual threads, Apache HTTP client with HTTP/2 support
message-router.sqs.max-messages-per-poll=10
message-router.sqs.wait-time-seconds=20
message-router.activemq.receive-timeout-ms=1000
# Disable metrics polling temporarily to test ACK
message-router.metrics.poll-interval-seconds=300

# HTTP Mediator Configuration
mediator.http.version=HTTP_2
%dev.mediator.http.version=HTTP_1_1

# REST Client Configuration (to fetch router config)
# Full URL including path, e.g., http://localhost:8000/api/config
quarkus.rest-client.message-router-config.url=${MESSAGE_ROUTER_CONFIG_URL:http://localhost:8080/api/config}
quarkus.rest-client.message-router-config.scope=jakarta.inject.Singleton
quarkus.rest-client.message-router-config.connect-timeout=3000
quarkus.rest-client.message-router-config.read-timeout=5000
quarkus.rest-client.message-router-config.http2=${CONFIG_CLIENT_HTTP2:true}

# SQS Configuration (when using SQS)
quarkus.sqs.endpoint-override=${SQS_ENDPOINT_OVERRIDE:}
quarkus.sqs.aws.region=${AWS_REGION:eu-west-1}
quarkus.sqs.aws.credentials.type=default

# AWS SDK HTTP Client Configuration (Apache HTTP Client for Sync)
# Configure Apache HTTP client with HTTP/2 support and connection pooling for 265+ concurrent consumers
quarkus.sqs.sync-client.apache.use-idle-connection-reaper=true
quarkus.sqs.sync-client.apache.connection-max-idle-time=60
quarkus.sqs.sync-client.apache.max-connections=500
quarkus.sqs.sync-client.apache.connection-time-to-live=300

# Note: SDK timeouts are configured per-request in SqsQueueConsumer (25s for polling, 10s for metrics)
# This prevents hung requests when LocalStack or network issues occur

# Dev profile - LocalStack local SQS
%dev.quarkus.sqs.endpoint-override=http://localhost:4566
%dev.quarkus.sqs.aws.region=eu-west-1
%dev.quarkus.sqs.aws.credentials.type=static
%dev.quarkus.sqs.aws.credentials.static-provider.access-key-id=test
%dev.quarkus.sqs.aws.credentials.static-provider.secret-access-key=test

# ActiveMQ Configuration (when using ACTIVEMQ)
activemq.broker.url=${ACTIVEMQ_BROKER_URL:tcp://localhost:61616}
activemq.username=${ACTIVEMQ_USERNAME:admin}
activemq.password=${ACTIVEMQ_PASSWORD:admin}

# NATS JetStream Configuration (when using NATS)
# Connection settings
message-router.nats.servers=${NATS_SERVERS:nats://localhost:4222}
message-router.nats.connection-name=flowcatalyst-router
message-router.nats.username=${NATS_USERNAME:}
message-router.nats.password=${NATS_PASSWORD:}

# Stream and consumer settings
message-router.nats.stream-name=${NATS_STREAM_NAME:FLOWCATALYST}
message-router.nats.consumer-name=${NATS_CONSUMER_NAME:flowcatalyst-router}
message-router.nats.subject=${NATS_SUBJECT:flowcatalyst.dispatch.>}

# Consumer behavior (matching SQS settings)
message-router.nats.max-messages-per-poll=10
message-router.nats.poll-timeout-seconds=20
message-router.nats.ack-wait-seconds=120
message-router.nats.max-deliver=10
message-router.nats.max-ack-pending=1000

# Storage configuration (File for production, Memory for dev)
message-router.nats.storage-type=File
message-router.nats.replicas=1
message-router.nats.max-age-days=7

# Dev profile - single replica, can use Memory for faster testing
%dev.message-router.nats.replicas=1
%dev.message-router.nats.storage-type=File

# Embedded Queue DataSource (SQLite4j - pure Java for native image)
quarkus.datasource.embedded-queue.db-kind=sqlite
quarkus.datasource.embedded-queue.jdbc.url=jdbc:sqlite:./flowcatalyst-queue.db
quarkus.datasource.embedded-queue.jdbc.max-size=16
quarkus.datasource.embedded-queue.devservices.enabled=false

# NO DATABASE - Message router is stateless!
# Disable default datasource (not needed - only using named datasource for embedded queue)
quarkus.datasource.jdbc=false

# Queue Health Monitoring
queue.health.monitor.enabled=true
queue.health.backlog.threshold=1000
queue.health.growth.threshold=100

# Notification System
notification.enabled=true
notification.batch.interval=5m
notification.min.severity=WARNING

# Email Notifications (opt-in)
notification.email.enabled=false
notification.email.from=flowcatalyst@example.com
notification.email.to=ops@example.com

# Quarkus Mailer SMTP Configuration
quarkus.mailer.from=${notification.email.from}
quarkus.mailer.host=smtp.example.com
quarkus.mailer.port=587
quarkus.mailer.start-tls=REQUIRED
quarkus.mailer.username=
quarkus.mailer.password=
quarkus.mailer.mock=true

# Production mailer config
%prod.quarkus.mailer.mock=false

# Microsoft Teams Webhook Notifications (opt-in)
notification.teams.enabled=false
notification.teams.webhook.url=

# Authentication Configuration
# Opt-in authentication for standalone deployment
# Valid values: NONE, BASIC, OIDC
authentication.enabled=false
authentication.mode=NONE

# BasicAuth Configuration
# Username and password for basic authentication (use ENV vars in deployment)
authentication.basic-username=${AUTH_BASIC_USERNAME:}
authentication.basic-password=${AUTH_BASIC_PASSWORD:}

# OIDC Configuration
# IMPORTANT: Do not set quarkus.oidc.enabled here! It must be controlled via environment variable.
# Set QUARKUS_OIDC_ENABLED=true in Fargate to enable OIDC
# If not set, OIDC will not initialize (which is correct for dev mode)
%dev.quarkus.oidc.enabled=false
quarkus.oidc.auth-server-url=
quarkus.oidc.client-id=
quarkus.oidc.credentials.secret=
quarkus.oidc.application-type=web-app
quarkus.oidc.authentication.redirect-path=/oidc/callback
quarkus.oidc.authentication.restore-path-after-redirect=true
quarkus.oidc.authentication.session-age-extension=2H
quarkus.oidc.authentication.java-script-auto-redirect=false
# Microsoft Entra ID (Azure AD) specific
quarkus.oidc.authentication.scopes=openid,profile,email

# HTTP Auth Permissions
# Public paths (health checks, metrics, and OIDC callback) are always accessible
quarkus.http.auth.permission.public.paths=/health/*,/q/health/*,/q/metrics,/metrics,/monitoring/health,/oidc/*
quarkus.http.auth.permission.public.policy=permit
# Protected paths - dashboard and monitoring endpoints require authentication
# When OIDC enabled, unauthenticated users will be redirected to Microsoft login
quarkus.http.auth.permission.protected.paths=/monitoring/dashboard,/monitoring/standby-status,/monitoring/queue-stats,/api/*
quarkus.http.auth.permission.protected.policy=authenticated
quarkus.http.auth.permission.protected.enabled=false

# Hot Standby Configuration (opt-in)
# Enables distributed primary/standby mode with Redis-based leader election
# Uses Quarkus Redis client with Lua scripts (native image compatible)
# If disabled, single instance operates normally without Redis dependency
# Automatic lock renewal (watchdog) refreshes locks at TTL/3 interval
standby.enabled=false
standby.instance-id=${HOSTNAME:instance-1}
standby.lock-key=message-router-primary-lock
standby.lock-ttl-seconds=30

# Quarkus Redis Configuration (required only if standby.enabled=true)
# Uses Quarkus Redis client - native image compatible (unlike Redisson)
quarkus.redis.hosts=redis://${REDIS_HOST:localhost}:${REDIS_PORT:6379}
quarkus.redis.timeout=10s
quarkus.redis.max-pool-size=4
quarkus.redis.max-pool-waiting=16

# Dev profile: Local Redis without auth
%dev.quarkus.redis.hosts=redis://localhost:6379

# Prod profile: TLS with authentication
%prod.quarkus.redis.hosts=rediss://${REDIS_HOST}:${REDIS_PORT}
%prod.quarkus.redis.password=${REDIS_PASSWORD:}
%prod.quarkus.redis.tls.enabled=true
%prod.quarkus.redis.tls.trust-all=false
